package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"

	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/parser"
)

func (s client) InterfaceName() string {
	return s.UppercaseName() + "Service"
}

func (s client) RecieverName() string {
	return strings.ToLower(s.Name[:1])
}

func (s client) UppercaseName() string {
	return strings.ToUpper(s.Name[:1]) + s.Name[1:]
}

func (s client) LowercaseName() string {
	return s.RecieverName() + s.Name[1:]
}

func (s client) StructName() string {
	return fmt.Sprintf("%sClient", s.LowercaseName())
}

func (s client) Reciever() string {
	return fmt.Sprintf("%s *%s", s.RecieverName(), s.StructName())
}

func (s client) EndpointConstName() string {
	return fmt.Sprintf("%sDefaultEndpoint", s.LowercaseName())
}

func (s client) ServiceConstName() string {
	return fmt.Sprintf("%sServiceName", s.LowercaseName())
}

func gqlScalarTypeToGo(t string) string {
	t = strings.TrimSuffix(t, "!")
	switch t {
	case "ID", "String", "URL":
		return "string"
	case "Boolean":
		return "bool"
	case "Int":
		return "int"
	case "Float":
		return "float64"
	default:
		return t
	}
}

func Generate(cfg config) error {
	// For each service (name and filename) parse the queries and generate
	// a Go file containing an interface with all related queries, a struct
	// which implements the interface, and finally a factory function that
	// returns an instance of said struct.
	for _, c := range cfg.Clients {
		log.Printf("generating for service %s (%s)...\n", c.Name, c.GoFile)

		fileBytes, err := os.ReadFile(c.GQLFile)
		if err != nil {
			return err
		}

		fileSource := &ast.Source{
			Input: string(fileBytes),
			Name:  c.GQLFile,
		}

		document, gqlErr := parser.ParseQuery(fileSource)
		if gqlErr != nil {
			panic(gqlErr)
		}

		w, err := os.OpenFile(c.GoFile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
		if err != nil {
			return fmt.Errorf("could not open file %q for writing: %w", c.GQLFile, err)
		}

		if err := generateServiceFile(cfg.PackageName, c, document, w); err != nil {
			return fmt.Errorf("failed to generate %q service: %w", c.Name, err)
		}
	}

	return nil
}

func writeOperationFunctionSignature(w io.Writer, operation *ast.OperationDefinition) {
	fmt.Fprintf(w, "%s(ctx context.Context ", operation.Name)
	// Write each variable definiton as a Go function parameter.
	for _, variable := range operation.VariableDefinitions {
		fmt.Fprintf(w, ", %s %s", variable.Variable, gqlScalarTypeToGo(variable.Type.Name()))
	}
	fmt.Fprintf(w, ") (*%sResponse, error)", operation.Name)
}

func writeInterface(w io.Writer, c client, operations []*ast.OperationDefinition) {
	fmt.Fprintf(w, "type %s interface {\n", c.InterfaceName())
	for _, operation := range operations {
		fmt.Fprint(w, "\t")
		writeOperationFunctionSignature(w, operation)
		fmt.Fprintln(w)
	}
	fmt.Fprintf(w, "}\n")
}

func writeStruct(w io.Writer, c client, operations []*ast.OperationDefinition) {
	fmt.Fprintf(w, "type %s struct{\n\tclient graphql.Client\n}\n", c.StructName())
	for _, operation := range operations {
		fmt.Fprintf(w, "func (%s) ", c.Reciever())
		writeOperationFunctionSignature(w, operation)
		fmt.Fprintln(w, " {")
		fmt.Fprintf(w, "\t return %s(ctx, %s.client, ", operation.Name, c.RecieverName())
		for _, variable := range operation.VariableDefinitions {
			fmt.Fprintf(w, "%s, ", variable.Variable)
		}
		fmt.Fprint(w, ")\n}\n\n")
	}
}

func writeFactory(w io.Writer, c client) {
	fmt.Fprintf(w, "func New%sClient(authToken string, accountID string) %s {\n", c.UppercaseName(), c.InterfaceName())
	fmt.Fprintf(w, "\ttransport := client.NewAuthedTransport(authToken, accountID, %s)\n", c.ServiceConstName())
	fmt.Fprintf(w, "\treturn &%s{client: graphql.NewClient(%s, transport)}\n", c.StructName(), c.EndpointConstName())
	fmt.Fprintln(w, "}\n")
}

func writeConstants(w io.Writer, c client) {
	fmt.Fprintln(w, "const (")
	fmt.Fprintf(w, "\t%s = \"%s\"\n", c.ServiceConstName(), c.ServiceName)
	fmt.Fprintf(w, "\t%s = \"%s/graphql\"\n", c.EndpointConstName(), c.BaseURL)
	fmt.Fprintln(w, ")\n")
}

func writeImports(w io.Writer, pkgs ...string) {
	fmt.Fprintf(w, "import(\n\t\"%s\"\n)\n\n", strings.Join(pkgs, "\"\n\t\""))
}

func generateServiceFile(packageName string, c client, document *ast.QueryDocument, file io.Writer) error {
	fileBuf := new(bytes.Buffer)

	fmt.Fprintf(fileBuf, "package %s\n// Generated by ./cmd/service-client-gen\n\n", packageName)
	writeImports(fileBuf,
		"context",
		"github.com/Khan/genqlient/graphql",
		"github.com/lifeomic/terraform-provider-phc/internal/client")
	writeConstants(fileBuf, c)

	writeInterface(fileBuf, c, document.Operations)
	fmt.Fprintln(fileBuf)
	writeStruct(fileBuf, c, document.Operations)
	fmt.Fprintln(fileBuf)
	writeFactory(fileBuf, c)
	fmt.Fprintln(fileBuf)

	// Run go fmt on file buffer before writing it to the out file. This is
	// useful because it also validates the go syntax.
	p, err := format.Source(fileBuf.Bytes())
	if err != nil {
		return fmt.Errorf("format failed with: %w\nsource: %s", err, fileBuf.String())
	}

	_, err = file.Write(p)
	return err
}
